#!/usr/bin/python3

import argparse, os, subprocess, sys, time
import kcore.docker_lib as d_lib

DOCKER_BIN = os.environ.get('DOCKER_EXEC', 'docker')


def main():
    ap = argparse.ArgumentParser(description='kcore-baseline test')
    d_lib.add_testing_args(ap)
    args = ap.parse_args()
    name, ip, cow, dv = d_lib.launch_or_find_container(
        args, ['--cmd=/bin/sleep 3'])
    if not cow or not ip: sys.exit('cannot find container %s (try re-running test with "-r"..?)' % name)

    # ---- Check that our files/prep got put into place.
    d_lib.container_file_expect('APK_CLEANUP=1', name, '/prep')

    # ---- Very basic check that a file created in the container can be seen
    # in the copy-on-write dir.  This isn't particularly profound, but at
    # least confirms the infrastructure needed for other containers' tests.
    cookie = d_lib.gen_random_cookie()
    subprocess.check_call([DOCKER_BIN, 'exec', '-u', '0', name,
                           '/bin/bash', '-c', 'echo "%s" > /root/cookie' % cookie])
    d_lib.file_expect(cookie, cow + '/root/cookie')

    # ---- Make sure kcore works (if this fails, might need to change Makefile
    # install path to match a new Python version
    #d_lib.popen_inside_expect(name, 'python3 -c "import kcore.common; print(\'ok\')"', 'ok', expect_returncode=0)
    d_lib.popen_inside_expect(name, ['python3', '-c', 'import kcore.common; print("ok")'], 'ok', expect_returncode=0)

    # ---- Make sure bash-history is being recorded in cow dir.
    # TODO: can't find a way to run this in an automated way that looks sufficiently
    # like it's interactive so that bash records it.  Tried various combinations of
    # passing -ti to docker and -il to bash, no joy.  Disabling for now.
    # On the plus side, actual interactive sessions do seem to get logged.
    ## d_lib.file_expect(cookie, cow + '/root/.bash_history')

    print('pass')

    # TODO: launch a local server and test kmc against it.

if __name__ == "__main__":
  main()

