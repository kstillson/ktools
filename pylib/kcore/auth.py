#!/usr/bin/python3
'''A client-machine-locked authentication token generator.

This is essentially a shared-secret based system for a client to authenticate
to a server, but it's got a few extra twists:

1. The shared secret (hereafter referred to as the "client registration") is
derived from several components, including one that is obtained from the
hardware of the client (e.g. the motherboard serial number).  So even if the
same username/password is used, validation will fail if its attempted from a
different client machine.

2. Neither the client-machine-specific data nor the derived registration code
is stored anywhere on the disk of client machines, so even an attacker with
access to a full disk backup of the client cannot impersonate it.

3. The secret client registrations are stored on the server, but a mechanism
is provided to keep them encrypted, so full disk backups of the server
also shouldn't compromise security.

4. Authentication tokens also contain the time-stamp when they were created-
to prevent replay attacks, and a hash of the command being validated- to
prevent transferring tokens from a valid command to an invalid one.

                  --------------------------------

An example session using the command-line interface:

>> [one time] On the client machine, we generate the shared registration secret:
CLIENT$ k_auth -g -u user1 -p pass1
v2:blue2:user1:0d4b17b4080cc2ada031ceb276b5beec9f06b95e

>> [one time] On the server, we register that secret:
SERVER$ k_auth --db-passwd db123 -r v2:blue2:user1:0d4b17b4080cc2ada031ceb276b5beec9f06b95e

>> On the client, we generate a token to authenticate a command:
CLIENT$ k_auth -c 'command1' -u user1 -p pass1
v2:blue2:user1:1648266958:8c0c0da11eed666e3fefd0a30263f84ee6f671e7

>> On the server, we validate the token for that command:
SERVER$ k_auth --db-passwd db123 -v v2:blue2:user1:1648266958:8c0c0da11eed666e3fefd0a30263f84ee6f671e7 -c 'command1'
validated? True

This successful validation demonstrates that:

- The command was not changed between token creation and validation.

- The token was created recently and hasn't been used before.

- The same password was used during secret generation and token creation.

- The same machine was used for secret generation and token creation.

Note that we didn't have to store the generated secret on the client,
and the password was never given to the server.


TODO: separate out a auth_base that depends only on hashlib, so it can work
with Circuit Python. (https://docs.circuitpython.org/en/latest/docs/library/hashlib.html)

                  --------------------------------

The shared secret is generated by combining client-machine-unique-data with
the username and password.  Why not just generate a random number?  Because
then we'd have to save it on the client.  The goal is to authenticate as the
user (using the password) *and* as the sending machine, but in a way the
client machine can be backed up without allowing someone possessing the backup
to impersonate the client machine.

If the sending machine is a single user system (e.g. a Raspberry Pi just
running a single service), you can skip the username and password: the
hostname and machine-unique-data take their place.  However, if the client is
not running as root and not on a Raspberry Pi, you might consider using a
password anyway, as the client-machine-unique-data might need to fall back to
using the root disk's UUID, which can be revealed in system logs.

Notes:

- "username" is unrelated to Linux uids; it's just an arbitrary string used to
  distinguish different authentication subjects from the same client machine.

- Tokens contain the username, source hostname, and time in plaintext.
  Including the hostname allows for source-ip validation.  You can set the
  hostname to "*" to disable source-ip validation, but tokens will still only
  validate if generated using the same client-generated secret (which is
  client-machnine specific, unless you override it by setting $PUID).

- The server-side logic will remember the last timestamp accepted from each
  {hostname+username}, and require each subsequent request to be later than
  the previous ones.  THIS IMPLIES A LIMIT OF 1 VALIDATION REQUEST PER SECOND.
  You can turn this check off in the validation request call, or it will be
  disabled implicitly if the module doesn't persist between checks.

- Indepentently, the server-side validator checks that the time of the token
  generation (included in the token) is within an acceptance window of the
  server's current time.  This prevents replay attacks only after the window
  has expired, so pick your acceptance window-size accordingly (along with how
  closely you can keep your client and server clocks in sync).

- If you want to register all your secrets on the server-side, rather than 
  switching back and forth between client and server (as outlined above), see
  services/keymaster/km-helper.py.

'''

import argparse, hashlib, getpass, json, os, socket, subprocess, sys, time
from dataclasses import dataclass

import kcore.uncommon as UC

PY_VER = sys.version_info[0]


# ---------- global constants and types

DEBUG = False   # WARNING- outputs lots of secrets!
DEFAULT_MAX_TIME_DELTA = 90
DEFAULT_DB_FILENAME = 'kcore_auth_db.data.gpg'
TOKEN_VERSION = 'v2'

class AuthNError(Exception):
  pass


# ---------- general purpose helpers

def compare_hostnames(host1, host2):
  '''Compare hosts by name and/or IP address.'''
  
  if host1 == host2: return True

  # Translate hostnmes to IP addresses and then compare those.
  try:
    if not host1[0].isdigit(): host1 = socket.gethostbyname(host1)
    if not host2[0].isdigit(): host2 = socket.gethostbyname(host2)
  except Exception: return False
  return host1 == host2


def safe_read(filename):
  '''Return file contents or none on error'''
  try:
    with open(filename) as f: return f.read().strip()
  except Exception:
    return None


# ---------- authN general helpers

def get_machine_private_data():
  '''Get a private piece of data unique to the local machine.

  This function tries a number of methods of getting machine-private data.  It
  doesn't really matter which one works, so long as the generated
  per-machine-data is consistent, reasonably unique, and private.  "Private"
  data ideally shouldn't be stored on the local hard-disk, because such data is
  often backed up and becomes difficult to track and protect.  It also certainly
  shouldn't be transmitted with every network packet (the way a MAC address is).

  When running in a Docker container (or similar), there really may be no
  suitable container-specific secret.  The cgroup id changes each container
  launch, so it fails the "consistent" requirement.  For this reason, this
  method checks the environment variable $PUID ("platform unique id"), and
  will unquestioningly use the value there if provided.  Docker container
  clients should arrange for this variable to be populated, preferably with
  the value returned by this method from outside the container, or with a
  random-but-persistent per-container value.

  The method will throw an AuthNError exception if it can't generate a value
  that seems to meet all the requirements.
  '''
  puid = os.environ.get('PUID')
  if puid: return puid

  # This works well on general Linux, but by default requires root.  We don't
  # want to just attempt to read it and use it if it works, because then we
  # get different PUID values when root and non-root ask, and sometimes both
  # root and non-root users will want to generate tokens from the same
  # machine.  So...  It turns out root can grant read permissions to this file
  # to others, but it's non-persistent (i.e. reset upon reboot).  So we'll
  # check that the file perms allow "other+read", and only use this file if
  # so.  Therefore, to enable this (preferred) method, the sysadmin should add
  # this command to the system start-up process:
  #        chmod 444 /sys/class/dmi/id/product_uuid
  #
  fil = '/sys/class/dmi/id/product_uuid'
  if os.path.isfile(fil) and os.stat(fil).st_mode & 0o4 > 0:
    puid = safe_read(fil)
    if puid: return 'v2p:dpu:' + puid

  # This generally works well on Raspberry PI's.
  cpuinfo = safe_read('/proc/cpuinfo')
  for line in cpuinfo.split('\n'):
    if 'Serial' in line:
      _, puid = line.split(': ', 1)
      return 'v2p:csn:' + puid

  # And finally fall back on the uuid of the root risk (this isn't ideal
  # because it's not guaranteed to be unique against major upgrade changes
  # and is sometimes available on disk in the boot logs).
  blk_ids = subprocess.check_output(['lsblk', '-nro', 'UUID,MOUNTPOINT'])
  if PY_VER == 3: blk_ids = blk_ids.decode(sys.stdout.encoding)
  for line in blk_ids.split('\n'):
    if line.endswith(' /'):
      puid, _ = line.split(' ', 1)
      return 'v2p:rbi:' + puid

  raise AuthNError('unable to find suitable machine private data. consider setting $PUID.')


def hasher(plaintext):
  '''Return sha1 hash of a string as a string. Py2 or 3.'''
  if PY_VER == 3: plaintext = plaintext.encode('utf-8')
  return hashlib.sha1(plaintext).hexdigest()


def registration_secret_name(hostname, username): return '%s:%s' % (hostname, username)


def now(): return int(time.time())


# ---------- client-side authN logic

def generate_shared_secret(use_hostname=None, username='', user_password=''):
  '''Generate the shared secret used to register a client.

     Should be run on the client machine because machine-specific data is
     merged into the generated data (unless $PUID is used).

     The output of this method is a string that should be passed to register()
     on the server(s) where token validation will be performed.  The client
     does not need to save this shared secret; it will be automatically
     re-generated when generate_token() is called.

     You generally don't want to override the hostname: pass None and allow
     the method to autodetect the client's hostname.  This is because by
     default the server will check to see if a client's request is actually
     coming from the hostname it was registered with.  

     There are two advanced-usage exceptions: 

     (1) passing '*' as the hostname will tell the server not to check the
     remote address of a request based off this shared secret.  This can allow
     the secret to be retrieved by multiple hosts- HOWEVER- the shared secret
     still contains machine-specific data.  So if you really want the secret
     to be retriable from any host, you'll also need to set $PUID both before
     generating the secret with this method also, with the same $PUID value,
     each time any client generates a token that will be validated with the
     registration generated here.

     (2) it is sometimes convenient to generate a registration secret on some
     system other than the client (e.g. the server).  To do this, you get the
     machine-specific data from the client machine (see
     get_machine_private_data()), and securely transfer that to the system
     where you want to generate the shared secret registration, and set $PUID
     with the client's machine-specific data when calling this method.

  '''
  
  hostname = use_hostname or socket.gethostname()
  data_to_hash = '%s:%s:%s:%s' % (hostname, get_machine_private_data(), username, user_password)
  if DEBUG: print('DEBUG: client registration hash data: %s' % data_to_hash, file=sys.stderr)
  return '%s:%s:%s:%s' % (TOKEN_VERSION, hostname, username, hasher(data_to_hash))


def generate_token(command, use_hostname=None, username='', user_password='', override_time=None):
  '''Generate a token that authenticates "command".

     The generated token can be validated using validate_token() [below].
     Before validation will work, the client generating a token must register
     a shared secret with the server.  i.e. call generate_shared_secret() on
     the client, and then register() on the server.

     If "use_hostname" was used during shared secret generation, e.g. "*" was
     used to enable multi-host retrieval, the same "use_hostname" value must
     be passed here, or the token won't validate.  That's because this method
     works by re-generating the registration secret, so you don't have to 
     store it on the client.'''
  
  regenerated_registration = generate_shared_secret(use_hostname, username, user_password)
  return generate_token_given_shared_secret(
    command, regenerated_registration, use_hostname, username, override_time)


def generate_token_given_shared_secret(
    command, shared_secret, use_hostname=None, username='', override_time=None):
  '''Generate a token for "command" given a pre-generated shared secret.

     This method is really for internal-use by the validation side of the
     logic, but...

     Part of the idea of the auth module is that client's shouldn't have to
     save their shared secret, as it can be regenerated during token
     creation.  However, if for some reason you have a shared secret and
     want to generate a token from it, this method can do it for you.'''
    
  hostname = use_hostname or socket.gethostname()
  time_now = override_time or now()
  plaintext_context = '%s:%s:%s:%s' % (TOKEN_VERSION, hostname, username, time_now)
  data_to_hash = '%s:%s:%s' % (plaintext_context, command, shared_secret)
  if DEBUG: print('DEBUG: hash data: "%s"' % data_to_hash, file=sys.stderr)
  return '%s:%s' % (plaintext_context, hasher(data_to_hash))


# ---------- server-side authN logic

# This data is not persisted beyond module lifetime.
LAST_RECEIVED_TIMES = {}  # maps command-specific-key-name -> epoch seconds of most recent success.


@dataclass
class ValidationResults:
  ok: bool
  status: str
  registered_hostname: str
  username: str
  sent_time: int
  

def validate_token(token, command, client_addr, db_passwd,
                   must_be_later_than_last_check=True, max_time_delta=DEFAULT_MAX_TIME_DELTA,
                   db_filename=DEFAULT_DB_FILENAME, override_expected_client_addr=None):
  '''Validate "token" for "command", using a previously registered shared secret.

     client_addr can be an IP address in string format, a hostname, or None.
     Passing None as client_addr will disable the check that the incoming
     request is coming from the hostname set during registration.  However,
     this undermines an important aspect of this module's security model.

     Returns: ValidationResults

  '''

  global REGISTRATION_DB
  if not REGISTRATION_DB:
    cnt = load_registration_db(db_passwd, db_filename)
    if cnt <= 0:
      if DEBUG: print(f'DEBUG: load reg db {db_filename} failed. passwd={db_passwd}, cnt={cnt}', file=sys.stderr)
      return ValidationResults(False, f'unable to open/decrypt registration database {db_filename}', None, None, None)
    
  token_version, registered_hostname, username, sent_time_str, sent_auth = token.split(':', 4)
  shared_secret = get_shared_secret_from_db(registered_hostname, username)
  if not shared_secret:
    return ValidationResults(False, f'could not find client registration for {registered_hostname,}:{username}', None, None, None)
  
  return validate_token_given_shared_secret(
    token=token, command=command, shared_secret=shared_secret,
    client_addr=client_addr, override_expected_client_addr=override_expected_client_addr,
    must_be_later_than_last_check=must_be_later_than_last_check, max_time_delta=max_time_delta)


def validate_token_given_shared_secret(
    token, command, shared_secret,
    client_addr, override_expected_client_addr=None,
    must_be_later_than_last_check=True, max_time_delta=DEFAULT_MAX_TIME_DELTA):
  '''Validate "token" for "command", using a provided shared secret.

     Normally you validate tokens using validate_token().  However, if you're
     using some other mechanism other than this module's built-in database to
     persist registration shared-secrets, you can perform token validation
     using this method.

     By default, the expected hostname will be pulled out of the provided
     shared secret, which was generally created on the client.  However, the
     hostname/address by which the client knows itself differs from the one
     the server will see (due to DNS or NAT issues), you can override the
     "expected_client_addr" to tell the server what address it should expect
     to match "client_addr" (which is generally provided by the web server).

     The expected hostname check can be bypassed if the expected client addr
     (from either the param or extracted from the shared secret) is "*", or if
     the caller provides None as the actual client_addr.  Bypassing the client
     identity check undermines an important aspect of this module's security
     model.

     Returns ValidationResults

  '''

  if DEBUG: print(f'DEBUG: starting validation token={token} command={command} shared_secret={shared_secret} client_addr={client_addr}', file=sys.stderr)
  try:
    token_version, shared_secret_expected_hostname, username, sent_time_str, sent_auth = token.split(':', 4)
    sent_time = int(sent_time_str)
  except Exception:
    return ValidationResults(False, 'token fails to parse', None, None, None)

  if token_version != TOKEN_VERSION:
    return ValidationResults(False, f'Wrong token/protocol version.   Saw "{token_version}", expected "{TOKEN_VERSION}".', shared_secret_expected_hostname, username, sent_time)

  expected_hostname = override_expected_client_addr or shared_secret_expected_hostname
  if client_addr and expected_hostname != '*' and not compare_hostnames(expected_hostname, client_addr):
    return ValidationResults(False, f'Wrong hostname.  Saw "{client_addr}", expected "{expected_hostname}".', expected_hostname, username, sent_time)

  if max_time_delta:
    time_now = now()
    time_delta = abs(time_now - sent_time)
    if time_delta > max_time_delta:
      return ValidationResults(False, f'Time difference too high.  sent:{sent_time} now:{time_now},  delta {time_delta} > {max_time_delta}', expected_hostname, username, sent_time)

  if must_be_later_than_last_check:
    keyname = f'{expected_hostname}:{username}:{command}'
    if keyname not in LAST_RECEIVED_TIMES:
      LAST_RECEIVED_TIMES[keyname] = sent_time
    else:
      if sent_time <= LAST_RECEIVED_TIMES[keyname]:
        return ValidationResults(False, f'Received token is not later than a previous token: {sent_time} < {LAST_RECEIVED_TIMES[keyname]}', expected_hostname, username, sent_time)

  expect_token = generate_token_given_shared_secret(command, shared_secret, shared_secret_expected_hostname, username, sent_time)
  if DEBUG: print(f'DEBUG: expect_token={expect_token} expected_hostname={expected_hostname}', file=sys.stderr)
  if token != expect_token: return ValidationResults(False, f'Token fails to validate  Saw "{token}", expected "{expect_token}".', expected_hostname, username, sent_time)

  return ValidationResults(True, 'ok', expected_hostname, username, sent_time)


# ---------- server-side persistence

REGISTRATION_DB = None     # maps registration_secret_name -> registration blob

def load_registration_db(db_passwd, db_filename=DEFAULT_DB_FILENAME):
  '''Returs number of entries in db, or -1 on error.'''
  global REGISTRATION_DB
  REGISTRATION_DB = {}
  if not os.path.isfile(db_filename):
    if DEBUG: print(f'DEBUG: reg file {db_filename} does not exist; starting fresh.', file=sys.stderr)
    return 0
  try:
    with open(db_filename) as f: encrypted = f.read()
    decrypted = UC.gpg_symmetric(encrypted, db_passwd)
    if decrypted.startswith('ERROR'):
      if DEBUG: print(f'DEBUG: error during decryption: {decrypted}', file=sys.stderr)
      return -1
    REGISTRATION_DB = json.loads(decrypted)
    if DEBUG: print(f'DEBUG: loaded ok.  {len(REGISTRATION_DB)} entries.', file=sys.stderr)
    return len(REGISTRATION_DB)
  except Exception as e:
    if DEBUG: print(f'DEBUG: exception during decrypt: {str(e)}', file=sys.stderr)
    return -1


def get_shared_secret_from_db(hostname, username):
  '''Must call load_registration_db first.'''
  return REGISTRATION_DB.get(registration_secret_name(hostname, username))


def register(shared_secret, db_passwd, db_filename=DEFAULT_DB_FILENAME):
  token_version, hostname, username, _hash = shared_secret.split(':')
  if token_version != TOKEN_VERSION: return False

  global REGISTRATION_DB
  if REGISTRATION_DB is None:
    if db_filename: load_registration_db(db_passwd, db_filename)
    else: REGISTRATION_DB = {}

  keyname = registration_secret_name(hostname, username)
  REGISTRATION_DB[keyname] = shared_secret

  if db_filename:
    plaintext = json.dumps(REGISTRATION_DB).replace(', ',',\n ')
    encrypted = UC.gpg_symmetric(plaintext, db_passwd, decrypt=False)
    if encrypted.startswith('ERROR'): return False
    with open(db_filename, 'w') as f: f.write(encrypted)

  return True


# ---------- command-line interface

def parse_args(argv):
  ap = argparse.ArgumentParser(description='authN token generator')
  ap.add_argument('--username', '-u', default='', help='Does not need to match Linux usernames, they are arbitrary strings.')
  ap.add_argument('--password', '-p', default='', help='when using multiple-users per machine, this secret identifies a particular user')
  ap.add_argument('--hostname', '-H', default=None, help='required for server-side commands;  autodetected if not specified for client-side commands')
  
  group1 = ap.add_argument_group('client-side registration', 'client registration')
  group1.add_argument('--generate', '-g', action='store_true', help='generate a shared secret that includes a hashed machine-specific secret from this machine (i.e. must be run on the machine where future client requests will originate, unless $PUID is used.)')

  group2 = ap.add_argument_group('server-side registration', 'register a client (enable token validation from that client)')
  group2.add_argument('--register', '-r', default=None, metavar='SHARED_SECRET', help='register the shared secret from the client\'s --generate command')
  group2.add_argument('--db-filename', '-f', default=DEFAULT_DB_FILENAME, help='name of file on server to store shared registration secrets')
  group2.add_argument('--db-passwd', '-P', default=None, help='GPG passphrase for --filename.  Default ("-") to query from stdin.  Use "$X" to read password from environment variable X')

  group3 = ap.add_argument_group('create token', 'creating an authentication token on the client')
  group3.add_argument('--command', '-c', default=None, help='specify the command to generate or verify a token for')

  group4 = ap.add_argument_group('validate token', 'check a validation token on the server')
  group4.add_argument('--verify', '-v', default=None, metavar='TOKEN', help='verify the provided token.  Must also provide --hostname, --command, and --db-passwd.  Must provide --username and --password if used, and --filename if not using the default.')
  group4.add_argument('--max-time-delta', '-m', default=DEFAULT_MAX_TIME_DELTA, type=int, help='max # seconds between token generation and consumption.')

  group5 = ap.add_argument_group('special' 'other alternate modes')
  group5.add_argument('--extract-machine-secret', '-e', action='store_true', help='run on the client to output the machine-unique-private data and stop.  See -s.')
  group5.add_argument('--use-machine-secret', '-s', default=None, help='on the client, use this provided client machine secret rather than querying the machine for its real secret.  Equivalent to setting $PUID.')

  return ap.parse_args(argv)

# ----------

def main(argv=[]):
  args = parse_args(argv or sys.argv[1:])
  
  if args.extract_machine_secret:
    print(get_machine_private_data())
    return 0

  if args.use_machine_secret: os.environ['PUID'] = args.use_machine_secret

  if args.db_passwd:
    if args.db_passwd == "-":
        args.db_passwd = getpass.getpass(f'Enter value for registration database: ')
    elif args.db_passwd.startswith('$'):
        varname = args.db_passwd[1:]
        tmp = os.environ.get(args.db_passwd[1:])
        if tmp: args.db_passwd = tmp
        else: sys.exit(f'--db-passwd indicated to use {args.db_passwd}, but variable is not set.')
    
  if args.generate:
    if not args.password: sys.exit('WARNING: password not specified.  Registering a host without a password will allow anyone with access to the host to authenticate as the host.  If this is really what you want, specify "-" as the password.')
    password = '' if args.password == '-' else args.password
    if args.username and not password: sys.exit('specifying a username without a password is not useful.')
    print(generate_shared_secret(args.hostname, args.username, password))
    return 0

  elif args.register:
    if not args.db_passwd: sys.exit('must provide --db-passwd to --register.')
    ok = register(args.register, args.db_passwd, args.db_filename)
    if ok:
      print('Done.  Registration file now has %d entries.' % len(REGISTRATION_DB))
      return 0
    print('Something went wrong (wrong --db-passwd?)')
    return -1

  elif args.command and not args.verify:
    print(generate_token(args.command, args.hostname, args.username, args.password))
    return 0

  elif args.verify:
    if not args.db_passwd: sys.exit('must provide --db-passwd to --verify.')
    rslt = validate_token(token=args.verify, command=args.command, db_passwd=args.db_passwd,
                          client_addr=args.hostname, max_time_delta=args.max_time_delta)
    friendly_time = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(rslt.sent_time))
    print(f'validated? {rslt.ok}\nstatus: {rslt.status}\ngenerated on host: {rslt.registered_hostname}\ngenerated by user: {rslt.username}\ntime sent: {rslt.sent_time} ({friendly_time})')
    return 0

  else:
    print('nothing to do...  specify one of --generate, --register, --command, --verify')
    return -2


if __name__ == '__main__':
  sys.exit(main())

