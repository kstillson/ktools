'''
Docker related support library

TODO: doc

'''

import atexit, glob, os, random, ssl, string, sys
import kcore.common as C
import kcore.uncommon as UC

PY_VER = sys.version_info[0]

DLIB=os.environ.get('DLIB', None)
if not DLIB:
    DLIB = '/var/lib/docker/200000.200000'
    if not os.path.isdir(DLIB): DLIB = '/var/lib/docker'

OUT = sys.stdout

# ----------------------------------------
# Intended as external command targets (generally called by ~/bin/d)


def get_cid(container_name):  # or None if container not running.
    out = UC.popener(['/usr/bin/docker', 'ps', '--format', '{{.ID}} {{.Names}}', '--filter', 'name=' + container_name])
    for line in out.split('\n'):
        if ' ' not in line: continue
        cid, name = line.split(' ', 1)
        if name == container_name: return cid
    return None


def latest_equals_live(container_name):
    try:
        ids = UC.popener(
            ['/usr/bin/docker', 'images', '--filter=reference=ktools/%s' % container_name,
             '--format="{{.Tag}} {{.ID}}"'])
        id_map = {}
        for lines in ids.split('\n'):
            tag, did = lines.split(' ')
            id_map[tag.replace('"', '')] = did
        if id_map['latest'] == id_map['live']:
            return 'true'
        return 'false'
    except:
        return 'unknown'


def run_command_in_container(container_name, cmd):
    command = ['/usr/bin/docker', 'exec', '-u', '0', container_name]
    if isinstance(cmd, list): command.extend(cmd)
    else: command.append(cmd)
    return UC.popener(command)


def find_cow_dir(container_name):
    try:
        id_prefix = UC.popener(['/usr/bin/docker', 'ps', '--filter', 'name=%s' % container_name, '--format', '{{.ID}}']).replace('\n', '')
    except:
        sys.exit('cannot find container (is it up?)')
    globname = DLIB + '/image/overlay2/layerdb/mounts/%s*/mount-id' % id_prefix
    files = glob.glob(globname)
    if not files: sys.exit('ouch; docker naming convensions have changed: %s' % globname)
    with open(files[0]) as f: cow = f.read()
    return DLIB + '/overlay2/%s/diff' % cow

def get_cow_dir(container_name): return find_cow_dir(container_name)  # alias for above


# ----------------------------------------
# Testing related

def emit(msg): OUT.write('>> %s\n' % msg)

def abort(msg):
    emit(msg)
    sys.exit(msg)

def add_testing_args(ap):
    ap.add_argument('--name', '-n', help='Override default name of container to launch and/or test')
    ap.add_argument('--out',  '-o', default='-', help='Where to send all output generated by the test')
    ap.add_argument('--prod', '-p', action='store_true', help='Test the production container, rather than the dev container')
    ap.add_argument('--run',  '-r', action='store_true', help='Start up the container to test')
    ap.add_argument('--tag',  '-t', default='latest', help='If using --run, what image tag to launch')

def launch_or_find_container(args, extra_run_args=None):
    global OUT
    name = orig_name = args.name or os.path.basename(os.getcwd())
    if not args.prod: name = 'test-' + name
    args.real_name = name

    if args.out == '-':
        OUT = sys.stdout
    else:
        dir = os.path.dirname(args.out)
        if dir and not os.path.isdir(dir):
            os.mkdir(dir)
            os.chown(dir, 200000, 200000)
        OUT = open(args.out, 'w')

    if args.run:
        atexit.register(stop_container_at_exit, args)
        launch_test_container(args, extra_run_args, OUT)
        if os.fork() == 0:
            run_log_relay(args, OUT)
            sys.exit(0)

    try: ip = UC.popener(['/root/bin/d', 'ip', name])
    except: ip = None
    cow = find_cow_dir(name)
    dv = '/rw/dv/%s' % name if args.prod else '/rw/dv/TMP/%s' % orig_name
    return name, ip, cow, dv

def launch_test_container(args, extra_run_args, out):
    emit('launching container ' + args.real_name)
    cmnd = ['/root/bin/d-run', '--log', 'json-file', '--tag', args.tag, '--print-cmd']
    if args.name: cmnd.extend(['--name', args.name])
    if extra_run_args: cmnd.extend(extra_run_args)
    if not args.prod:
        cmnd.extend(['--name_prefix', 'test-', '--network', 'docker2',
                     '--rm', '--subnet', '3', '-v'])
    emit(' '.join(cmnd))
    rslt = UC.popen(cmnd, stdout=out, stderr=out)
    if not rslt.ok: sys.exit(rslt.out)

def run_log_relay(args, out):
    rslt = UC.popen(['/usr/bin/docker', 'logs', '-f', args.real_name], stdout=out, stderr=out)
    if not rslt.ok: sys.exit(rslt.out)
    emit('log relay done.')


def stop_container_at_exit(args):
    if not args.run or args.prod: return False   # Don't stop something we didn't start.
    if not args.real_name: return False
    cid = get_cid(args.real_name)
    if not cid: return False    # Already stopped
    rslt = UC.popener(['/usr/bin/docker', 'stop', '-t', '2', args.real_name])
    return not rslt.startswith('ERROR')


# filename is in the regular (jack host) filesystem.
def file_expect(expect, filename, invert=False, missing_ok=False):
    ok = os.path.isfile(filename)
    if not ok:
        if missing_ok: return emit('success; file %s missing, and thats ok.' % filename)
        else: abort('file %s not found' % filename)

    with open(filename) as f: contents = f.read()
    if expect is None:
        if not contents: return emit('file %s empty, as expected' % filename)
        else: abort('file %s not empty, but was expected to be.' % filename)
    if invert:
        if not expect in contents: return emit('success; "%s" NOT in %s, as expected' % (expect, filename))
        else: abort('found "%s" in %s when not expected' % (expect, filename))
    if expect in contents: return emit('success; "%s" in %s, as expected' % (expect, filename))
    else: abort('Unable to find "%s" in: %s' % (expect, filename))


# filename is inside the conainter.
def container_file_expect(expect, container_name, filename):
    data = UC.popener(['/usr/bin/docker', 'cp', '%s:%s' % (container_name, filename), '-'])
    if data.startswith('ERROR'): abort('error getting file %s:%s' % (container_name, filename))
    if expect in data:
        emit('success; saw "%s" in %s:%s' % (expect, container_name, filename))
        return 0
    abort('Unable to find "%s" in %s:%s' % (expect, container_name, filename))


# expect commnd run on host (not container) to return certain output and/or error text.
def popen_expect(cmd, expect_out, expect_err=None, expect_returncode=None, send_in=None):
    rslt = UC.popen(cmd, send_in)
    if expect_returncode is not None and rslt.returncode != expect_returncode: abort('wrong return code: %d <> %d for %s' % (rslt.returncode, expect_returncode, cmd))
    if expect_out is not None:
        if rslt.stdout and not expect_out: abort('Unexpected output "%s" for: %s' % (rslt.stdout, cmd))
        if expect_out not in rslt.stdout: abort('Unable to find output "%s" in "%s" for: %s' % (expect_out, rslt.stdout, cmd))
    if expect_err is not None:
        if rslt.stderr and not expect_err: abort('Unexpected error output "%s" for: %s', (rslt.stderr, cmd))
        if expect_err and expect_err not in rslt.stderr: abort('Unable to find error "%s" in "%s" for: %s' % (expect_err, rslt.stderr, cmd))
    emit('success; expected output for %s' % cmd)


# expect can be a string or a list.  if list, accept any substring.
def web_expect(expect, server, path, port=80, expect_status=None, post_params=None, headers={}, https=False, timeout=2, size_limit=512, proxy_host=None, verify_ssl=True):
    proto = 'https' if https else 'http'
    if path[0] == '/': path = path[1:]
    url = '%s://%s:%d/%s' % (proto, server, port, path)
    resp = C.web_get(url, timeout=timeout, post_dict=post_params, verify_ssl=verify_ssl, proxy_host=proxy_host)
    if resp.exception: emit('web_get exception: %s' % resp.exception)
    if expect_status and expect_status != resp.status_code:
        abort('Web get returned unexpected status: %s : %s <> %s' % (url, expect_status, resp.status_code))
    if not isinstance(expect, list):
        expect = [expect]
    for e in expect:
        if e in resp.text:
            emit('success; saw "%s" in %s' % (e, url))
            return 0
    abort('Unable to find "%s" in: %s; response: %s' % (expect, url, resp.text))


def gen_random_cookie(len=15):
    return ''.join(random.choice(string.ascii_letters) for i in range(len))

# Send a list of strings, read response after each and return in a list.
def socket_exchange(sock, send_list, add_eol=False, emit_transcript=False):
    resp_list = []
    for i in send_list:
        if emit_transcript: emit('sending: %s' % i)
        if add_eol: i += '\n'
        if PY_VER == 3: i = i.encode('utf-8')
        sock.sendall(i)
        resp = sock.recv(1024)
        if PY_VER == 3: resp = resp.decode('utf-8')
        resp = resp.strip()
        if emit_transcript: emit('received: %s' % resp)
        resp_list.append(resp)
    return resp_list

